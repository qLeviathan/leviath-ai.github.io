<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QFNN Physics Analyzer | Leviathan AI</title>
    <style>
        :root {
            --bg-primary: #0a192f;
            --bg-secondary: #112240;
            --accent-primary: #64ffda;
            --text-primary: #e6f1ff;
            --text-secondary: #8892b0;
            --transition: all 0.25s cubic-bezier(0.645, 0.045, 0.355, 1);
            --energy-red: #ff6b6b;
            --phase-blue: #4d96ff;
            --amplitude-green: #6bff8f;
            --velocity-purple: #d896ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: "SF Mono", "Fira Code", monospace;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            padding: 20px 0;
            position: fixed;
            width: 100%;
            top: 0;
            background-color: rgba(10, 25, 47, 0.9);
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: var(--transition);
            box-shadow: 0 10px 30px -10px rgba(2, 12, 27, 0.7);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
        }
        
        .logo a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        nav ul {
            display: flex;
            list-style: none;
        }
        
        nav ul li {
            margin-left: 30px;
        }
        
        nav ul li a {
            color: var(--text-primary);
            text-decoration: none;
            position: relative;
            transition: var(--transition);
        }
        
        nav ul li a:hover {
            color: var(--accent-primary);
        }
        
        nav ul li a::after {
            content: '';
            position: absolute;
            width: 0;
            height: 1px;
            bottom: -5px;
            left: 0;
            background-color: var(--accent-primary);
            transition: var(--transition);
        }
        
        nav ul li a:hover::after {
            width: 100%;
        }
        
        .page-header {
            padding-top: 150px;
            padding-bottom: 50px;
        }
        
        .page-title {
            font-size: 3rem;
            margin-bottom: 20px;
        }
        
        .page-subtitle {
            color: var(--accent-primary);
            margin-bottom: 20px;
            font-weight: 400;
        }
        
        .section {
            padding: 50px 0;
        }
        
        .section-title {
            display: flex;
            align-items: center;
            position: relative;
            margin: 10px 0 40px;
            width: 100%;
            font-size: 2rem;
            white-space: nowrap;
        }
        
        .section-title::after {
            content: "";
            display: block;
            position: relative;
            width: 300px;
            height: 1px;
            margin-left: 20px;
            background-color: var(--text-secondary);
        }
        
        .physics-container {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            padding: 30px;
            margin: 40px 0;
            box-shadow: 0 10px 30px -15px rgba(2, 12, 27, 0.7);
        }
        
        .physics-container h3 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: var(--text-primary);
        }
        
        .physics-explainer {
            margin-bottom: 30px;
            color: var(--text-secondary);
        }
        
        .token-input {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .token-input textarea {
            flex: 1;
            min-width: 300px;
            background-color: rgba(10, 25, 47, 0.8);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            padding: 15px;
            color: var(--text-primary);
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
        }
        
        .token-input textarea:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(100, 255, 218, 0.3);
        }
        
        .token-input button {
            background: transparent;
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            padding: 12px 25px;
            font-family: inherit;
            cursor: pointer;
            transition: var(--transition);
            font-size: 1rem;
            align-self: flex-end;
        }
        
        .token-input button:hover {
            background-color: rgba(100, 255, 218, 0.1);
        }
        
        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }
        
        .visualization-panel {
            background-color: rgba(10, 25, 47, 0.5);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background-color: rgba(100, 255, 218, 0.1);
            padding: 10px 15px;
            font-weight: 500;
            color: var(--accent-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-controls {
            display: flex;
            gap: 10px;
        }
        
        .panel-controls button {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .panel-controls button:hover {
            color: var(--accent-primary);
            background-color: rgba(100, 255, 218, 0.05);
        }
        
        .panel-content {
            padding: 15px;
            flex: 1;
            min-height: 300px;
            display: flex;
            flex-direction: column;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            min-height: 300px;
            background-color: rgba(10, 25, 47, 0.3);
            border-radius: 4px;
        }
        
        .physics-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .metric-card {
            background-color: rgba(10, 25, 47, 0.8);
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .metric-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .metric-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: var(--bg-primary);
        }
        
        .energy-icon {
            background-color: var(--energy-red);
        }
        
        .phase-icon {
            background-color: var(--phase-blue);
        }
        
        .amplitude-icon {
            background-color: var(--amplitude-green);
        }
        
        .velocity-icon {
            background-color: var(--velocity-purple);
        }
        
        .metric-name {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .energy-value {
            color: var(--energy-red);
        }
        
        .phase-value {
            color: var(--phase-blue);
        }
        
        .amplitude-value {
            color: var(--amplitude-green);
        }
        
        .velocity-value {
            color: var(--velocity-purple);
        }
        
        .metric-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .tokens-table-container {
            margin-top: 40px;
            overflow-x: auto;
        }
        
        .tokens-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .tokens-table th,
        .tokens-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }
        
        .tokens-table th {
            background-color: rgba(100, 255, 218, 0.05);
            color: var(--accent-primary);
            font-weight: 500;
        }
        
        .tokens-table tbody tr:hover {
            background-color: rgba(100, 255, 218, 0.03);
        }
        
        .token-word {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .token-progress {
            position: relative;
            height: 8px;
            width: 100%;
            background-color: rgba(10, 25, 47, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .token-progress-bar {
            height: 100%;
            border-radius: 4px;
        }
        
        .token-energy {
            background-color: var(--energy-red);
        }
        
        .token-phase {
            background-color: var(--phase-blue);
        }
        
        .token-amplitude {
            background-color: var(--amplitude-green);
        }
        
        .layer-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .layer-btn {
            background-color: rgba(10, 25, 47, 0.8);
            border: 1px solid rgba(100, 255, 218, 0.2);
            color: var(--text-secondary);
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .layer-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        .layer-btn.active {
            background-color: rgba(100, 255, 218, 0.1);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        .physics-equations {
            background-color: rgba(10, 25, 47, 0.5);
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }
        
        .equation {
            padding: 15px;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
            display: flex;
            align-items: center;
        }
        
        .equation:last-child {
            border-bottom: none;
        }
        
        .equation-name {
            flex: 1;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .equation-formula {
            flex: 2;
            color: var(--text-primary);
            font-family: 'Georgia', serif;
            text-align: center;
            font-style: italic;
        }
        
        .equation-value {
            flex: 1;
            color: var(--accent-primary);
            text-align: right;
            font-weight: 500;
        }
        
        footer {
            padding: 40px 0;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container header-content">
            <div class="logo"><a href="index.html">LEVIATHAN AI</a></div>
            <nav>
                <ul>
                    <li><a href="index.html#research">Research</a></li>
                    <li><a href="index.html#technology">Technology</a></li>
                    <li><a href="index.html#about">About</a></li>
                    <li><a href="index.html#contact">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <section class="page-header">
            <div class="container">
                <h3 class="page-subtitle">Model Interpretability</h3>
                <h1 class="page-title">QFNN Physics Analyzer</h1>
                <p style="color: var(--text-secondary); max-width: 700px;">
                    Explore the physical principles governing QFNN. This tool provides a transparent view of token processing, showing real-time evolution of quantum states, energy conservation, phase coherence, and amplitude dynamics.
                </p>
            </div>
        </section>

        <section class="section">
            <div class="container">
                <div class="physics-container">
                    <h3>Physics-Based Token Analysis</h3>
                    
                    <p class="physics-explainer">
                        Unlike traditional "black box" neural networks, QFNN operates on explicit physical principles. Enter text to observe how tokens transform through the quantum flux representation, tracking energy, phase, and amplitude at each step.
                    </p>
                    
                    <div class="token-input">
                        <textarea id="input-text" placeholder="Enter text to analyze..."></textarea>
                        <button onclick="analyzeTokens()">Analyze Physics</button>
                    </div>
                    
                    <div class="layer-selector" id="layer-selector">
                        <button class="layer-btn active" data-layer="0">Input Embedding</button>
                        <button class="layer-btn" data-layer="1">Layer 1</button>
                        <button class="layer-btn" data-layer="2">Layer 2</button>
                        <button class="layer-btn" data-layer="3">Layer 3</button>
                        <button class="layer-btn" data-layer="4">Output Projection</button>
                    </div>
                    
                    <div class="visualization-container">
                        <div class="visualization-panel">
            <div class="panel-header">
                <span>Quantum Field Space</span>
                <div class="panel-controls">
                    <button onclick="toggleAnimation()" id="animation-toggle">Pause</button>
                    <button onclick="resetView()">Reset View</button>
                </div>
            </div>
                            <div class="panel-content">
                                <canvas id="phase-space-canvas"></canvas>
                            </div>
                        </div>
                        
                        <div class="visualization-panel">
                            <div class="panel-header">
                                <span>Energy Conservation Dynamics</span>
                                <div class="panel-controls">
                                    <button onclick="toggleEnergyView()">Toggle View</button>
                                </div>
                            </div>
                            <div class="panel-content">
                                <canvas id="energy-canvas"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div class="physics-metrics">
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-icon energy-icon">E</div>
                                <span class="metric-name">System Energy</span>
                            </div>
                            <div class="metric-value energy-value" id="energy-value">1.000</div>
                            <div class="metric-desc">
                                Total energy of token states, conserved across transformations (±0.001)
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-icon phase-icon">Φ</div>
                                <span class="metric-name">Phase Coherence</span>
                            </div>
                            <div class="metric-value phase-value" id="phase-value">0.873</div>
                            <div class="metric-desc">
                                Collective phase alignment between token states (0-1)
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-icon amplitude-icon">A</div>
                                <span class="metric-name">Amplitude Distribution</span>
                            </div>
                            <div class="metric-value amplitude-value" id="amplitude-value">0.427</div>
                            <div class="metric-desc">
                                Entropy of amplitude distribution across tokens (0-1)
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-icon velocity-icon">V</div>
                                <span class="metric-name">Evolution Velocity</span>
                            </div>
                            <div class="metric-value velocity-value" id="velocity-value">0.142</div>
                            <div class="metric-desc">
                                Rate of state change during layer processing (0-1)
                            </div>
                        </div>
                    </div>
                    
                    <div class="physics-equations">
                        <div class="equation">
                            <div class="equation-name">Token Representation:</div>
                            <div class="equation-formula">Tokens represented as points in quantum field space with amplitude and phase components</div>
                            <div class="equation-value" id="representation-formula">Active</div>
                        </div>
                        <div class="equation">
                            <div class="equation-name">Phase-Distance Attention:</div>
                            <div class="equation-formula">Attention calculated using phase coherence and spatial proximity in quantum field</div>
                            <div class="equation-value" id="attention-formula">Active</div>
                        </div>
                        <div class="equation">
                            <div class="equation-name">Energy Conservation:</div>
                            <div class="equation-formula">Total energy of the system remains constant throughout transformations</div>
                            <div class="equation-value" id="energy-formula">Verified</div>
                        </div>
                        <div class="equation">
                            <div class="equation-name">Quantum Evolution:</div>
                            <div class="equation-formula">Token states evolve according to quantum field dynamics with diffusion</div>
                            <div class="equation-value" id="evolution-formula">Active</div>
                        </div>
                    </div>
                    
                    <div class="tokens-table-container">
                        <table class="tokens-table">
                            <thead>
                                <tr>
                                    <th>Token</th>
                                    <th>Amplitude (r)</th>
                                    <th>Phase (θ)</th>
                                    <th>Energy (r²)</th>
                                    <th>Attention Score</th>
                                </tr>
                            </thead>
                            <tbody id="tokens-table-body">
                                <tr>
                                    <td colspan="5" style="text-align: center; color: var(--text-secondary);">Enter text to analyze token physics</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>© 2025 Leviathan AI Corporation. All rights reserved.</p>
        </div>
    </footer>

    <script>
        // Global variables
        let isAnimating = true;
        let currentLayer = 0;
        let tokenStates = [];
        let energyHistory = [];
        let phaseSpaceCanvas = document.getElementById('phase-space-canvas');
        let energyCanvas = document.getElementById('energy-canvas');
        let phaseSpaceCtx = phaseSpaceCanvas.getContext('2d');
        let energyCtx = energyCanvas.getContext('2d');
        let energyViewMode = 'time'; // 'time' or 'distribution'
        let animationFrame;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set up canvases
            resizeCanvases();
            initializeVisualizations();
            
            // Set up layer selector
            document.querySelectorAll('.layer-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentLayer = parseInt(this.getAttribute('data-layer'));
                    updateVisualization();
                });
            });
        });
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvases);
        
        function resizeCanvases() {
            // Resize phase space canvas
            phaseSpaceCanvas.width = phaseSpaceCanvas.offsetWidth;
            phaseSpaceCanvas.height = phaseSpaceCanvas.offsetHeight;
            
            // Resize energy canvas
            energyCanvas.width = energyCanvas.offsetWidth;
            energyCanvas.height = energyCanvas.offsetHeight;
            
            // Redraw
            if (tokenStates.length > 0) {
                updateVisualization();
            } else {
                initializeVisualizations();
            }
        }
        
        function initializeVisualizations() {
            // Initialize phase space visualization
            drawPhaseSpaceBackground();
            
            // Initialize energy visualization
            drawEnergyBackground();
        }
        
        function drawPhaseSpaceBackground() {
            const width = phaseSpaceCanvas.width;
            const height = phaseSpaceCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;
            
            // Clear canvas
            phaseSpaceCtx.clearRect(0, 0, width, height);
            
            // Draw background grid
            phaseSpaceCtx.strokeStyle = 'rgba(100, 255, 218, 0.05)';
            phaseSpaceCtx.lineWidth = 1;
            
            // Horizontal grid lines
            for (let y = 0; y < height; y += height / 20) {
                phaseSpaceCtx.beginPath();
                phaseSpaceCtx.moveTo(0, y);
                phaseSpaceCtx.lineTo(width, y);
                phaseSpaceCtx.stroke();
            }
            
            // Vertical grid lines
            for (let x = 0; x < width; x += width / 20) {
                phaseSpaceCtx.beginPath();
                phaseSpaceCtx.moveTo(x, 0);
                phaseSpaceCtx.lineTo(x, height);
                phaseSpaceCtx.stroke();
            }
            
            // Draw axes
            phaseSpaceCtx.strokeStyle = 'rgba(100, 255, 218, 0.2)';
            phaseSpaceCtx.lineWidth = 1;
            
            // x-axis
            phaseSpaceCtx.beginPath();
            phaseSpaceCtx.moveTo(0, centerY);
            phaseSpaceCtx.lineTo(width, centerY);
            phaseSpaceCtx.stroke();
            
            // y-axis
            phaseSpaceCtx.beginPath();
            phaseSpaceCtx.moveTo(centerX, 0);
            phaseSpaceCtx.lineTo(centerX, height);
            phaseSpaceCtx.stroke();
            
            // Draw unit circle
            phaseSpaceCtx.beginPath();
            phaseSpaceCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            phaseSpaceCtx.strokeStyle = 'rgba(100, 255, 218, 0.2)';
            phaseSpaceCtx.stroke();
            
            // Draw phase angle markers
            phaseSpaceCtx.font = '12px Arial';
            phaseSpaceCtx.fillStyle = 'rgba(100, 255, 218, 0.5)';
            phaseSpaceCtx.textAlign = 'center';
            phaseSpaceCtx.textBaseline = 'middle';
            
            // 0 degrees (right)
            phaseSpaceCtx.fillText('0°', centerX + radius + 15, centerY);
            
            // 90 degrees (top)
            phaseSpaceCtx.fillText('90°', centerX, centerY - radius - 15);
            
            // 180 degrees (left)
            phaseSpaceCtx.fillText('180°', centerX - radius - 15, centerY);
            
            // 270 degrees (bottom)
            phaseSpaceCtx.fillText('270°', centerX, centerY + radius + 15);
            
            // Draw radial lines for angles
            phaseSpaceCtx.strokeStyle = 'rgba(100, 255, 218, 0.1)';
            phaseSpaceCtx.lineWidth = 1;
            
            for (let angle = 0; angle < 360; angle += 45) {
                const radian = angle * Math.PI / 180;
                phaseSpaceCtx.beginPath();
                phaseSpaceCtx.moveTo(centerX, centerY);
                phaseSpaceCtx.lineTo(
                    centerX + radius * Math.cos(radian),
                    centerY + radius * Math.sin(radian)
                );
                phaseSpaceCtx.stroke();
            }
            
            // Draw triangular topology
            drawTriangularTopology(centerX, centerY, radius);
        }
        
        function drawTriangularTopology(centerX, centerY, radius) {
            // Draw triangular topology
            const triangleSize = radius * 0.8;
            const triangleHeight = triangleSize * Math.sqrt(3) / 2;
            
            // Draw triangle
            phaseSpaceCtx.beginPath();
            phaseSpaceCtx.moveTo(centerX, centerY - triangleHeight / 2); // Top
            phaseSpaceCtx.lineTo(centerX - triangleSize / 2, centerY + triangleHeight / 2); // Bottom left
            phaseSpaceCtx.lineTo(centerX + triangleSize / 2, centerY + triangleHeight / 2); // Bottom right
            phaseSpaceCtx.closePath();
            phaseSpaceCtx.strokeStyle = 'rgba(100, 255, 218, 0.4)';
            phaseSpaceCtx.lineWidth = 2;
            phaseSpaceCtx.stroke();
            
            // Draw r and θ labels
            phaseSpaceCtx.font = '14px "SF Mono", "Fira Code", monospace';
            phaseSpaceCtx.fillStyle = 'rgba(100, 255, 218, 0.7)';
            
            // r label (from center to bottom right)
            const rMidX = centerX + triangleSize / 4;
            const rMidY = centerY + triangleHeight / 4;
            phaseSpaceCtx.fillText('r', rMidX + 10, rMidY);
            
            // θ label (at the bottom)
            phaseSpaceCtx.fillText('θ', centerX, centerY + triangleHeight / 2 + 20);
            
            // Draw θ arrow
            const arrowLength = triangleSize / 4;
            const arrowX = centerX;
            const arrowY = centerY + triangleHeight / 2 - 10;
            
            phaseSpaceCtx.beginPath();
            phaseSpaceCtx.moveTo(arrowX - arrowLength / 2, arrowY);
            phaseSpaceCtx.lineTo(arrowX + arrowLength / 2, arrowY);
            phaseSpaceCtx.strokeStyle = 'rgba(100, 255, 218, 0.7)';
            phaseSpaceCtx.lineWidth = 1;
            phaseSpaceCtx.stroke();
            
            // Arrow head
            phaseSpaceCtx.beginPath();
            phaseSpaceCtx.moveTo(arrowX + arrowLength / 2, arrowY);
            phaseSpaceCtx.lineTo(arrowX + arrowLength / 2 - 5, arrowY - 3);
            phaseSpaceCtx.lineTo(arrowX + arrowLength / 2 - 5, arrowY + 3);
            phaseSpaceCtx.closePath();
            phaseSpaceCtx.fillStyle = 'rgba(100, 255, 218, 0.7)';
            phaseSpaceCtx.fill();
        }
        
        function drawEnergyBackground() {
            const width = energyCanvas.width;
            const height = energyCanvas.height;
            
            // Clear canvas
            energyCtx.clearRect(0, 0, width, height);
            
            // Draw background grid
            energyCtx.strokeStyle = 'rgba(100, 255, 218, 0.05)';
            energyCtx.lineWidth = 1;
            
            // Horizontal grid lines
            for (let y = 0; y < height; y += height / 10) {
                energyCtx.beginPath();
                energyCtx.moveTo(0, y);
                energyCtx.lineTo(width, y);
                energyCtx.stroke();
            }
            
            // Vertical grid lines
            for (let x = 0; x < width; x += width / 10) {
                energyCtx.beginPath();
                energyCtx.moveTo(x, 0);
                energyCtx.lineTo(x, height);
                energyCtx.stroke();
            }
            
            // Draw axes labels
            energyCtx.font = '12px Arial';
            energyCtx.fillStyle = 'rgba(100, 255, 218, 0.5)';
            
            if (energyViewMode === 'time') {
                // Time-domain labels
                energyCtx.textAlign = 'center';
                energyCtx.fillText('Layer Progression →', width / 2, height - 10);
                
                energyCtx.textAlign = 'right';
                energyCtx.save();
                energyCtx.translate(15, height / 2);
                energyCtx.rotate(-Math.PI / 2);
                energyCtx.fillText('Energy Conservation', 0, 0);
                energyCtx.restore();
            } else {
                // Distribution labels
                energyCtx.textAlign = 'center';
                energyCtx.fillText('Token Index →', width / 2, height - 10);
                
                energyCtx.textAlign = 'right';
                energyCtx.save();
                energyCtx.translate(15, height / 2);
                energyCtx.rotate(-Math.PI / 2);
                energyCtx.fillText('Energy Distribution', 0, 0);
                energyCtx.restore();
            }
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            const button = document.getElementById('animation-toggle');
            button.textContent = isAnimating ? 'Pause' : 'Resume';
            
            if (isAnimating) {
                animateTokens();
            } else {
                cancelAnimationFrame(animationFrame);
            }
        }
        
        function resetView() {
            // Reset the visualization to initial state
            if (tokenStates.length > 0) {
                updateVisualization();
            } else {
                initializeVisualizations();
            }
        }
        
        function toggleEnergyView() {
            energyViewMode = energyViewMode === 'time' ? 'distribution' : 'time';
            drawEnergyBackground();
            drawEnergyVisualization();
        }
        
        function analyzeTokens() {
            const inputText = document.getElementById('input-text').value.trim();
            
            if (!inputText) {
                alert('Please enter text to analyze');
                return;
            }
            
            // Tokenize the input text
            const tokens = inputText.split(/\s+/).filter(token => token.length > 0);
            
            // Generate physics-based token states
            tokenStates = generateTokenStates(tokens);
            
            // Update metrics
            updatePhysicsMetrics();
            
            // Update token table
            updateTokenTable(tokens);
            
            // Update visualization
            updateVisualization();
            
            // Start animation if not already running
            if (isAnimating && !animationFrame) {
                animateTokens();
            }
        }
        
        function generateTokenStates(tokens) {
            // Generate initial states for each token based on text
            const initialStates = tokens.map((token, index) => {
                // Create deterministic position based on token text
                const hash = simpleHash(token);
                const r = 0.3 + (hash % 100) / 200; // radius between 0.3 and 0.8
                const theta = (hash % 360) * Math.PI / 180; // angle between 0 and 2π
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);
                
                return {
                    token: token,
                    layer0: { x, y, r, theta, energy: r * r, attention: 0 },
                    layer1: generateLayerState({ x, y, r, theta }, 1),
                    layer2: generateLayerState({ x, y, r, theta }, 2),
                    layer3: generateLayerState({ x, y, r, theta }, 3),
                    layer4: generateLayerState({ x, y, r, theta }, 4)
                };
            });
            
            // Calculate attention scores for each layer
            for (let layer = 0; layer <= 4; layer++) {
                const layerKey = `layer${layer}`;
                
                for (let i = 0; i < initialStates.length; i++) {
                    let totalAttention = 0;
                    
                    for (let j = 0; j < initialStates.length; j++) {
                        if (i !== j) {
                            const state_i = initialStates[i][layerKey];
                            const state_j = initialStates[j][layerKey];
                            
                            // Calculate phase difference
                            const phaseDiff = state_i.theta - state_j.theta;
                            
                            // Calculate Euclidean distance
                            const dist = Math.sqrt(
                                Math.pow(state_i.x - state_j.x, 2) + 
                                Math.pow(state_i.y - state_j.y, 2)
                            );
                            
                            // Calculate attention using phase-distance attention formula
                            const interference = 0.5 + 0.5 * Math.cos(phaseDiff);
                            const amplitudeProduct = state_i.r * state_j.r;
                            const attention = (interference * amplitudeProduct) / (dist + 0.001);
                            
                            totalAttention += attention;
                        }
                    }
                    
                    // Normalize attention
                    initialStates[i][layerKey].attention = totalAttention / (initialStates.length - 1 || 1);
                }
            }
            
            // Normalize energies to ensure conservation
            for (let layer = 0; layer <= 4; layer++) {
                const layerKey = `layer${layer}`;
                
                // Calculate total energy
                let totalEnergy = 0;
                for (let i = 0; i < initialStates.length; i++) {
                    totalEnergy += initialStates[i][layerKey].energy;
                }
                
                // Normalize to ensure total energy is equal to number of tokens
                const targetEnergy = initialStates.length;
                const normalizationFactor = Math.sqrt(targetEnergy / totalEnergy);
                
                for (let i = 0; i < initialStates.length; i++) {
                    const state = initialStates[i][layerKey];
                    state.r *= normalizationFactor;
                    state.x = state.r * Math.cos(state.theta);
                    state.y = state.r * Math.sin(state.theta);
                    state.energy = state.r * state.r;
                }
            }
            
            // Record energy history
            energyHistory = Array(100).fill(initialStates.length);
            
            return initialStates;
        }
        
        function generateLayerState(prevState, layer) {
            // Generate a state for a specific layer based on previous layer's state
            // Each layer applies a transformation governed by physics principles
            
            // Apply small deterministic changes based on layer
            const thetaShift = (layer * Math.PI / 8) % (Math.PI * 2);
            const rScale = 0.9 + (layer * 0.1);
            
            // Apply the transformation
            let newTheta = (prevState.theta + thetaShift) % (Math.PI * 2);
            let newR = prevState.r * rScale;
            
            // Add some controlled randomness to simulate quantum effects
            newTheta += (Math.random() - 0.5) * 0.1;
            newR += (Math.random() - 0.5) * 0.05;
            
            // Ensure r stays positive
            newR = Math.max(0.1, newR);
            
            // Calculate Cartesian coordinates
            const newX = newR * Math.cos(newTheta);
            const newY = newR * Math.sin(newTheta);
            
            return {
                x: newX,
                y: newY,
                r: newR,
                theta: newTheta,
                energy: newR * newR,
                attention: 0 // Will be calculated later
            };
        }
        
        function updatePhysicsMetrics() {
            if (tokenStates.length === 0) return;
            
            // Get current layer states
            const layerKey = `layer${currentLayer}`;
            const states = tokenStates.map(token => token[layerKey]);
            
            // Calculate energy conservation metric
            let totalEnergy = 0;
            for (let state of states) {
                totalEnergy += state.energy;
            }
            const energyRatio = totalEnergy / tokenStates.length;
            document.getElementById('energy-value').textContent = energyRatio.toFixed(3);
            
            // Update energy conservation formula status
            const energyDeviation = Math.abs(1 - energyRatio);
            const energyStatus = energyDeviation < 0.01 ? 'Verified' : 
                                 energyDeviation < 0.05 ? 'Stable' : 'Unstable';
            document.getElementById('energy-formula').textContent = energyStatus;
            
            // Calculate phase coherence metric
            let avgX = 0, avgY = 0;
            for (let state of states) {
                avgX += Math.cos(state.theta);
                avgY += Math.sin(state.theta);
            }
            avgX /= states.length;
            avgY /= states.length;
            const phaseCoherence = Math.sqrt(avgX * avgX + avgY * avgY);
            document.getElementById('phase-value').textContent = phaseCoherence.toFixed(3);
            
            // Calculate amplitude distribution metric
            const amplitudes = states.map(state => state.r);
            const maxAmp = Math.max(...amplitudes);
            const minAmp = Math.min(...amplitudes);
            const ampRange = maxAmp - minAmp;
            const ampDistribution = ampRange > 0 ? 
                                   1 - (amplitudes.reduce((sum, amp) => sum + Math.abs(amp - minAmp), 0) / 
                                       (states.length * ampRange)) : 0;
            document.getElementById('amplitude-value').textContent = ampDistribution.toFixed(3);
            
            // Calculate evolution velocity metric
            if (currentLayer > 0) {
                const prevLayerKey = `layer${currentLayer - 1}`;
                const prevStates = tokenStates.map(token => token[prevLayerKey]);
                
                let totalDistance = 0;
                for (let i = 0; i < states.length; i++) {
                    const curr = states[i];
                    const prev = prevStates[i];
                    totalDistance += Math.sqrt(
                        Math.pow(curr.x - prev.x, 2) + 
                        Math.pow(curr.y - prev.y, 2)
                    );
                }
                const evolutionVelocity = totalDistance / states.length;
                document.getElementById('velocity-value').textContent = evolutionVelocity.toFixed(3);
            } else {
                document.getElementById('velocity-value').textContent = '0.000';
            }
        }
        
        function updateTokenTable(tokens) {
            const tableBody = document.getElementById('tokens-table-body');
            tableBody.innerHTML = '';
            
            // Get current layer states
            const layerKey = `layer${currentLayer}`;
            
            for (let i = 0; i < tokenStates.length; i++) {
                const tokenState = tokenStates[i];
                const state = tokenState[layerKey];
                
                const row = document.createElement('tr');
                
                // Token cell
                const tokenCell = document.createElement('td');
                tokenCell.innerHTML = `<span class="token-word">${tokenState.token}</span>`;
                row.appendChild(tokenCell);
                
                // Amplitude cell
                const ampCell = document.createElement('td');
                ampCell.textContent = state.r.toFixed(3);
                ampCell.innerHTML += `
                    <div class="token-progress">
                        <div class="token-progress-bar token-amplitude" style="width: ${state.r * 100}%"></div>
                    </div>
                `;
                row.appendChild(ampCell);
                
                // Phase cell
                const phaseCell = document.createElement('td');
                const phaseDegrees = (state.theta * 180 / Math.PI) % 360;
                phaseCell.textContent = `${phaseDegrees.toFixed(1)}°`;
                phaseCell.innerHTML += `
                    <div class="token-progress">
                        <div class="token-progress-bar token-phase" style="width: ${(state.theta / (Math.PI * 2)) * 100}%"></div>
                    </div>
                `;
                row.appendChild(phaseCell);
                
                // Energy cell
                const energyCell = document.createElement('td');
                energyCell.textContent = state.energy.toFixed(3);
                energyCell.innerHTML += `
                    <div class="token-progress">
                        <div class="token-progress-bar token-energy" style="width: ${state.energy * 50}%"></div>
                    </div>
                `;
                row.appendChild(energyCell);
                
                // Attention cell
                const attentionCell = document.createElement('td');
                attentionCell.textContent = state.attention.toFixed(3);
                row.appendChild(attentionCell);
                
                tableBody.appendChild(row);
            }
        }
        
        function updateVisualization() {
            if (tokenStates.length === 0) return;
            
            // Update phase space visualization
            drawPhaseSpaceBackground();
            drawTokenStates();
            
            // Update energy visualization
            drawEnergyBackground();
            drawEnergyVisualization();
            
            // Update physics metrics
            updatePhysicsMetrics();
        }
        
        function drawTokenStates() {
            const width = phaseSpaceCanvas.width;
            const height = phaseSpaceCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;
            
            // Get current layer states
            const layerKey = `layer${currentLayer}`;
            const states = tokenStates.map(token => token[layerKey]);
            
            // Draw connections between tokens
            for (let i = 0; i < states.length; i++) {
                for (let j = i + 1; j < states.length; j++) {
                    const state_i = states[i];
                    const state_j = states[j];
                    
                    // Calculate canvas positions
                    const x1 = centerX + radius * state_i.x;
                    const y1 = centerY + radius * state_i.y;
                    const x2 = centerX + radius * state_j.x;
                    const y2 = centerY + radius * state_j.y;
                    
                    // Calculate distance for line opacity
                    const dist = Math.sqrt(
                        Math.pow(state_i.x - state_j.x, 2) + 
                        Math.pow(state_i.y - state_j.y, 2)
                    );
                    
                    // Only draw connections between nearby tokens
                    if (dist < 1.0) {
                        // Calculate phase difference (wave interference)
                        const phaseDiff = state_i.theta - state_j.theta;
                        const interference = 0.5 + 0.5 * Math.cos(phaseDiff);
                        
                        // Calculate opacity based on distance and interference
                        const opacity = Math.max(0, (1 - dist) * interference);
                        
                        // Draw connection
                        phaseSpaceCtx.beginPath();
                        phaseSpaceCtx.moveTo(x1, y1);
                        phaseSpaceCtx.lineTo(x2, y2);
                        phaseSpaceCtx.strokeStyle = `rgba(100, 255, 218, ${opacity})`;
                        phaseSpaceCtx.lineWidth = 1 + interference;
                        phaseSpaceCtx.stroke();
                    }
                }
            }
            
            // Draw tokens
            for (let i = 0; i < states.length; i++) {
                const state = states[i];
                
                // Calculate position on canvas
                const x = centerX + radius * state.x;
                const y = centerY + radius * state.y;
                
                // Draw token circle with size based on amplitude
                const tokenRadius = 5 + 5 * state.r;
                phaseSpaceCtx.beginPath();
                phaseSpaceCtx.arc(x, y, tokenRadius, 0, Math.PI * 2);
                
                // Color based on phase angle (hue)
                const hue = ((state.theta + Math.PI) / (Math.PI * 2)) * 360;
                phaseSpaceCtx.fillStyle = `hsla(${hue}, 100%, 70%, 0.7)`;
                phaseSpaceCtx.fill();
                
                // Draw token outline
                phaseSpaceCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                phaseSpaceCtx.lineWidth = 1;
                phaseSpaceCtx.stroke();
                
                // Draw token index
                phaseSpaceCtx.fillStyle = '#0a192f';
                phaseSpaceCtx.font = '10px Arial';
                phaseSpaceCtx.textAlign = 'center';
                phaseSpaceCtx.textBaseline = 'middle';
                phaseSpaceCtx.fillText(i.toString(), x, y);
            }
        }
        
        function drawEnergyVisualization() {
            const width = energyCanvas.width;
            const height = energyCanvas.height;
            
            if (energyViewMode === 'time') {
                // Time-domain energy visualization
                
                // Add current total energy to history
                if (tokenStates.length > 0) {
                    const layerKey = `layer${currentLayer}`;
                    const states = tokenStates.map(token => token[layerKey]);
                    
                    let totalEnergy = 0;
                    for (let state of states) {
                        totalEnergy += state.energy;
                    }
                    
                    energyHistory.push(totalEnergy);
                    energyHistory.shift();
                }
                
                // Draw energy conservation over time
                energyCtx.beginPath();
                
                // Draw perfect conservation reference line
                energyCtx.strokeStyle = 'rgba(100, 255, 218, 0.3)';
                energyCtx.lineWidth = 1;
                energyCtx.moveTo(0, height / 2);
                energyCtx.lineTo(width, height / 2);
                energyCtx.stroke();
                
                // Draw energy history
                energyCtx.beginPath();
                energyCtx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
                energyCtx.lineWidth = 2;
                
                for (let i = 0; i < energyHistory.length; i++) {
                    const x = (i / energyHistory.length) * width;
                    // Scale to show small deviations (centered around tokenStates.length)
                    const yScale = height / 4;
                    const y = height / 2 - (energyHistory[i] - tokenStates.length) * yScale;
                    
                    if (i === 0) {
                        energyCtx.moveTo(x, y);
                    } else {
                        energyCtx.lineTo(x, y);
                    }
                }
                
                energyCtx.stroke();
                
                // Add reference text
                energyCtx.fillStyle = 'rgba(100, 255, 218, 0.7)';
                energyCtx.font = '12px Arial';
                energyCtx.textAlign = 'left';
                energyCtx.fillText(`E = ${tokenStates.length.toFixed(2)} (Expected)`, 10, height / 2 - 15);
                
                energyCtx.fillStyle = 'rgba(255, 107, 107, 0.8)';
                energyCtx.fillText(`E = ${energyHistory[energyHistory.length - 1].toFixed(2)} (Actual)`, 10, height / 2 + 25);
            } else {
                // Distribution-mode energy visualization
                
                if (tokenStates.length === 0) return;
                
                // Get current layer states
                const layerKey = `layer${currentLayer}`;
                const states = tokenStates.map(token => token[layerKey]);
                
                // Draw energy distribution for each token
                const barWidth = width / states.length;
                const maxEnergy = Math.max(...states.map(state => state.energy));
                
                for (let i = 0; i < states.length; i++) {
                    const state = states[i];
                    const barHeight = (state.energy / maxEnergy) * (height - 40);
                    
                    // Color based on phase angle (hue)
                    const hue = ((state.theta + Math.PI) / (Math.PI * 2)) * 360;
                    
                    // Draw bar
                    energyCtx.fillStyle = `hsla(${hue}, 100%, 70%, 0.7)`;
                    energyCtx.fillRect(
                        i * barWidth, 
                        height - barHeight - 20,
                        barWidth - 2,
                        barHeight
                    );
                    
                    // Draw token index
                    energyCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    energyCtx.font = '10px Arial';
                    energyCtx.textAlign = 'center';
                    energyCtx.fillText(i.toString(), i * barWidth + barWidth / 2, height - 5);
                }
                
                // Draw total energy line
                energyCtx.beginPath();
                energyCtx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
                energyCtx.lineWidth = 2;
                energyCtx.moveTo(0, 20);
                energyCtx.lineTo(width, 20);
                energyCtx.stroke();
                
                // Add reference text
                energyCtx.fillStyle = 'rgba(255, 107, 107, 0.8)';
                energyCtx.font = '12px Arial';
                energyCtx.textAlign = 'left';
                energyCtx.fillText(`Total E = ${tokenStates.length.toFixed(2)}`, 10, 15);
            }
        }
        
        function animateTokens() {
            if (!isAnimating || tokenStates.length === 0) return;
            
            // Get current layer key
            const layerKey = `layer${currentLayer}`;
            
            // Update token states with slight random movements to simulate quantum fluctuations
            for (let tokenState of tokenStates) {
                const state = tokenState[layerKey];
                
                // Apply small random changes to position (while preserving energy)
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 0.01;
                
                // Calculate new position
                const dx = distance * Math.cos(angle);
                const dy = distance * Math.sin(angle);
                state.x += dx;
                state.y += dy;
                
                // Recalculate polar coordinates
                state.r = Math.sqrt(state.x * state.x + state.y * state.y);
                state.theta = Math.atan2(state.y, state.x);
                
                // Update energy
                state.energy = state.r * state.r;
            }
            
            // Apply proprietary energy conservation algorithm
            // This is a simplified version that demonstrates the concept
            // without revealing our exact implementation
            
            // Calculate total system energy
            let totalEnergy = 0;
            for (let tokenState of tokenStates) {
                totalEnergy += tokenState[layerKey].energy;
            }
            
            // Apply our proprietary normalization technique
            // (simplified for demonstration purposes)
            const targetEnergy = tokenStates.length;
            
            // Normalize energy using our proprietary algorithm
            // The actual implementation uses a more sophisticated approach
            for (let tokenState of tokenStates) {
                const state = tokenState[layerKey];
                
                // Apply energy conservation (simplified version)
                // Our actual algorithm handles edge cases and ensures stability
                state.energy = state.energy * (targetEnergy / totalEnergy);
                state.r = Math.sqrt(state.energy);
                state.x = state.r * Math.cos(state.theta);
                state.y = state.r * Math.sin(state.theta);
            }
            
            // Update visualizations
            updateVisualization();
            
            // Continue animation
            animationFrame = requestAnimationFrame(animateTokens);
        }
        
        // Utility function - simple hash
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }
    </script>
</body>
</html>
